/**
 * Return a transparent black CSS color.
 *
 * @param int $opacity
 */
@function black($opacity){
    @return rgba(0, 0, 0, $opacity);
}

/**
 * Return a transparent white CSS color.
 *
 * @param int $opacity
 */
@function white($opacity){
    @return rgba(255, 255, 255, $opacity);
}

/**
 * Take a list of classes and generate a selector list.
 *
 * @param list $classes
 * @param bool [$inherit] - Apply classes to the wrapping selector
 */
@function join-classes($classes, $inherit: true) {
    $selectors: ();

    @each $class in $classes {
        @if str-index($class, ".") != 0 {
            $class: "." + $class;
        }

        @if $inherit {
            $selectors: append($selectors, unquote("&" + $class), "comma");
        } @else {
            $selectors: append($selectors, unquote($class), "comma");
        }
    }

    @return $selectors;
}

/**
 * Remove the first selector character (#, .) from the class name or ID.
 *
 * @param string $selector
 */
@function remove-selector($selector) {
    @return str-slice($selector, 2, str-length($selector));
}

/**
 * Generate a class name and apply an optional prefix.
 *
 * @param string $class
 * @param string [$prefix]
 * @param string [$selector]
 */
@function class-name($class, $prefix: map-get($toolkit, "namespace"), $selector: ".") {
    $name: $class;

    @if str_slice($class, 1, 1) == $selector {
        $name: remove-selector($name);
    }

    @if $prefix != "" {
        $name: $prefix + $name;
    }

    @return $selector + $name;
}

/**
 * Build a class name in the BEM specification.
 *
 * @param string $block
 * @param string $element
 * @param string $modifier
 * @param string [$element-separator]
 * @param string [$modifier-separator]
 */
@function bem(
    $block: "",
    $element: "",
    $modifier: "",
    $element-separator: map-get($toolkit, "element-separator"),
    $modifier-separator: map-get($toolkit, "modifier-separator")
) {
    $name: $block;

    @if $element != "" {
        $name: $name + $element-separator + $element;
    }

    @if $modifier != "" {
        $name: $name + $modifier-separator + $modifier;
    }

    @return $name;
}

/**
 * Calculate the gutter spacing as a percentage. Use the max width of the grid to calculate against.
 *
 * @param int $width - The max width of the container
 * @param int $gutter - The space between each cell
 */
@function gutter($width, $gutter) {
    @return if($gutter, ((to-pixel($gutter) / to-pixel($width)) * 100 * 1%), 0%);
}

/**
 * Calculate the width of an individual element within a row. Take into account max widths and gutters.
 *
 * @param int $n - The current column
 * @param int $columns - The total number of columns
 * @param int $width - The max width of the container
 * @param int $gutter - The spacing in between each block
 */
@function span-width($n, $columns, $width, $gutter) {
    $row-width: 100%;
    $gutter-width: 0%;

    // If a gutter is set, remove width based on the sum of the gutter columns
    @if $gutter {
        $gutter-width: gutter($width, $gutter);
        $row-width: $row-width - ($gutter-width * ($columns - 1));
    }

    // The column width should span a division of the total width
    $span-width: ($row-width / $columns) * $n;

    // If a gutter is set, increase the column width to fill in the missing gaps
    @if $gutter and $n > 1 {
        $span-width: $span-width + (($n - 1) * $gutter-width);
    }

    @return $span-width;
}
